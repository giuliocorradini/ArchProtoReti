# DNS

Abbiamo visto tutti i livelli del TCP/IP. Adesso vediamo dei protocolli strettamente attinenti a Internet, ma non sono
dello stack TCP/IP: sono protocolli del layer applicativo.

L'acronimo sta per Domain Name System perché DNS è qualcosa di più che un protocollo. Ci consente di creare un sistema
di _naming_ e non di indirizzi, perché sono comprensibili agli utenti umani. I nomi si possono scegliere quasi
liberamente.

Il requisito fondamentale per cui è stato progettato è la scalabilità: deve funzionare a livello geografico per tutta
Internet.

Nel contesto di _forensics_ (analisi forense), ovvero tutte le attività per investigare cosa sta succedendo in un certo
contesto, è fondamentale per acquisire informazioni.

## Nomi

Vogliamo identificare ogni dispositivo su Internet con un indirizzo IP, e potenzialmente con un nome. Gli utenti possono
usare un nome per comunicare e il compito del DNS è proprio gestire la corrispondenza tra nomi e indirizzi IP.

I nomi vengono detti **hostname**, che possono essere stringhe alfanumeriche al più di 255 caratteri. Ogni IP potrebbe
essere identificato anche da più hostname.

> Un hostname è una struttura composta gerarchica, composta da diverse label unite dal separatore speciale `.`. Ci sono
vincoli su come fare le label: 63 caratteri ognuna e l'intero hostname non deve superare i 255 caratteri.

In origine erano consentiti solo alcuni caratteri alfanumerici, mentre ora possono contenere anche caratteri speciali
(sottinsieme di simboli Unicode) secondo la convenzione IDN. Questo è comodo per tutte le lingue non latine.

Esempi:

```
w3c.org
samba.ing.unimo.it
www.unimo.it
```

Vedendo semplicemente l'hostname o le label non abbiamo alcuna informazione tra gli indirizzi IP e l'hostname.

### Hostname canonico

L'hostname utilizza le label con una struttura gerarchica: l'ordine della gerarchia è al contrario rispetto ad IP.
Net ID a sinistra e host ID a destra, mentre qui la parte più generale è a destra.

I punti separano la gerarchia.

```
sun3.dii.ing.unimore.it
```

La prima label (da destra) è il country code e identifica in quale nazione è gestito l'host che si vede assegnato questo
nome; oppure chi lo gestisce.

La seconda label identifica l'organizzazione che gestisce l'host.

Gergalmente potremmo dire che questo è un nome completo: abbiamo tutte le informazioni che mi servono per identificarlo
a livello globale. L'hostname canonico è detto anche FQDN: **fully qualified domain name**.

L'_hostname relativo_ è solamente l'ultima label, ovvero il nome dell'host. `sun3` in questo caso.

Un altro aspetto dell'uso di DNS è semplificare la scrittura di software che accede a server in rete. Invece di
codificare l'indirizzo IP per un servizio (di cui non ho pieno controllo perché potrebbe venire assegnato dinamicamente
dall'autonomous system), codifico un nome di dominio. Basta tenere aggiornato il server DNS.

In contesti avanzati un singolo hostname potrà corrispondere a più indirizzi IP. Il DNS disaccoppia un'informazione utile
per l'aspetto pratico con le informazioni utili per aspetti tecnici.

Questo è un tradeoff perché introduciamo un layer aggiuntivo di complessità: prima di usare un indirizzo devo fare un
lookup dell'hostname. È un piccolo overhead da spendere per ottenere maggiore flessibilità.

Un **lookup** identifica la trasformazione da hostname a indirizzo, mentre da indirizzo a hostname è un'operazione
inversa ed è detta **reverse lookup**.

## Caratteristiche architetturali

Per gestire lookup e reverse lookup tra indirizzi e hostname è detta architettura distribuita. Non c'è un singolo server
o componente che gestisce tutte le traduzioni nome-indirizzo: non esiste un **DNS centrale**.

Ci sono una molteplicità di server il cui nome tecnico è **Nameserver**.

I diversi nameserver sono legati perché si delegano dei ruoli: alcuni nameserve saranno dedicati a risolvere certi nomi,
mentre altri risponderanno che per risolvere un certo nome bisogna rivolgersi ad altri.

Dal punto di vista delle performance, DNS introduce delle tecniche di caching su tutti i livelli. Il protocollo di
default utilizzato per comunicare è UDP (per motivi di performance, per evitare l'handshake). Oggi ci può essere
anche supporto per TLS e HTTPS, quindi si può utilizzare DNS su TCP.

TCP veniva utilizzato soltanto nei contesti di aggiornamenti di record tra nameserver.

DNS ha un'importanza molto alta: ci sono risvolti sia funzionali, organizzitivi e commerciali (valore economico dei nomi).
I nomi assegnati ai PC sono diventati quasi i nomi delle aziende.

Ad esempio Google è stato scelto perché era un dominio non ancora occupato e orecchiabile.

## Sicurezza

Il DNS è rilevante anche dal punto di vista della sicurezza: molti attacchi avvengono perché il sistema è pensato per
l'efficienza, la scalabilità, la performance ma non la sicurezza. Ci sono diverse tecniche come il _pharming_, _cache
poisoning_...

Un altro termine interessante è cybersquatting: registriamo un dominio simile a un altro. Questo ha portato a un sistema
di politiche detto ACPA da parte dell'ICANN.

Il contesto dei _punycode_ identifica un nome che a basso livello è differente da altri nomi, ma visualmente è identico
(all'occhio umano). Questo perché Unicode prevede simboli molto simili o a volte identici e indistinguibili.

## Nomi delle label

La label più a sinistra è il TLD: top level domain. La seconda informazione viene detta SLD: second level domain.

Il TLD può essere associato a una nazione: il country code e in questo caso viene chiamato _ccTLD_.

Esistono anche dei TLD non associati a delle nazioni: i generic _gTLD_. Concettualmente sono associati a uno scopo.
I `.com` sono per le aziende, mentre `.org` per le organizzazioni senza scopo di lucro etc.

Queste sono tutte intenzioni, poi i TLD vengono utilizzati anche per altri scopi.

C'è solo un TLD che è tecnico: il TLD `.arpa` serve per far funzionare alcuni meccanismi interni di DNS, ad esempio
viene utilizzato per gestire in maniera efficiente i reverse lookup.

Sono stati aggiunti altri TLD: gli unsponsored TLD come `.biz`, `.info` oppure `.eu`.

### Liberalizzazione

È stato creato un mercato per i TLD, ovvero si possono creare dei TLD con nomi a piacimento. Ad esempio `google` ha il
suo `.google`.

## Architettura

### Root

Fin'ora è invisibile, ma diventerà fondamentale. Ogni volta che scriviamo un FQDN, il nome non inizia da un TLD ma da
un punto (che viene omesso). La gerarchia ha un unico punto di partenza.

### Classi di nameserver

Abbiamo tanti nameserver che associamo a una classe di nomi. Associamo un nameserve al livello della gerarchia in cui
operano. Un root nameserver gestisce tutti i nomi al di sotto della sua route.

Ogni TLD è invece associato a dei top level domain. Quindi il nameserve dei `.it` gestisce tutti i nomi che terminano
in `.it`, e solo quelli.

Concettualmente abbiamo una categoria root che gestirà tutti i TLD. La gerarchia viene inizialmente mappata su _alcuni_
nameserver.

Da non confondere con i local nameserver: hanno un ruolo tecnico ma potenzialmente non gestiscono nomi (non sono
autoritativi).

I TLD nameserver sono tanti e abbiamo almeno un TLD nameserver per ogni TLD esistente. Ogni root nameserver ci consente
di andare sul nameserver del TLD di nostro interesse.

> Il root nameserver ha la lista dei TLD, ovvero ogni root nameserver ci potrà dare le informazioni su come raggiungere
un nameserver per i diversi TLD.

In modo simile la gestione viene propagata a tutti i livelli successivi. Ogni _ns_ ha delega di gestione per un sottinsieme
dei nomi.

Attenzione però che non è sempre strutturato così: la regola di domini e sottodomini è regolato dal concetto di zona, che
identifica l'insieme di domini e sottodomini per cui un _ns_ è responsabile.

Facciamo un esempio con `dii.ing.unimore.it`: `unimore.it` è costretta ad avere un nameserver specializzato per ogni
sottodominio? Chiaramente no, quindi introduciamo il concetto di zona: possiamo dire che il nameserver di `unimore` ha
in gestione anche i sottodomini due livelli sotto di lui (anche `dii.ing.unimore.it`).

Posso anche scegliere di gestire autonomamente i sottodomini `ing` con un nameserver a parte, mentre il ns di unimore
gestisce i sottodomini `fim`, `mat` etc.

> Un ns è sicuramente responsabile dei domini immediatamente successivi, ma potenzialmente può anche sapere informazioni
di n livelli sottostanti.

Questa gestione c'è dai domini dell'organizzazione in giù, di solito in root e TLD no.

Quando parliamo di root ns parliamo di un sistema distribuito. In DNS è presente un sistema ben definito per la
replicazione dei record. Abbiamo un master o primary server che legge i dati su una zona dal master file (l'unica
sorgente dati autoritativa per una zona), e con un protocollo le informazioni vengono propagate verso i secondary server.

Il meccanismo di aggiornamento sfrutta TCP. Mentre i lookup e reverse lookup è gestito in UDP.
