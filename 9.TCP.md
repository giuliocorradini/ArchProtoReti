# TCP

È il primo protocollo affidabile che studiamo. È orientato alla connessione, e ragiona sul fatto che abbiamo uno
stream di dati da inviare.

Vogliamo un canale di comunicazione affidabile "virtuale". I paccheti vanno comunque inviati su un canale inaffidabile
quindi dobbiamo rilevare eventuali errori e correggerli: ritrasmettere.

## Rilevazione errori

Usiamo il checksum per garantire _l'integrità_ rispetto a errori di trasmissione. Non serve per rilevare una perdita di
un pacchetto.

Perdite, duplicati e consegne non in ordine sono problematiche che non vengono rilevate dal checksum, ma che il
protocollo gestisce.

Ho un dato da inviare, che viene suddiviso in N pacchetti.

TCP vuole garantire tutte le garanzie di affidabilità. In alcuni contesti potrebbe non offrire le performance migliori,
perché in alcuni scenari applicativi queste cose non interessano.

Quando vogliamo implementare sono "alcune" garanzia, ripartiamo da UDP e implementiamo solo certe funzioni. Ad esempio
il protocollo [QUIC](https://quicwg.org), che è basato su UDP.

Per rilevare gli errori, il destinatario conferma la ricezione di un insieme di pacchetti. La ricezione corretta di un
dato viene seguita da un _acknowledgement_. I pacchetti di _ACK_ vengono inviati ogni volta che il destinatario conferma
la corretta ricezione di un messaggio.

L'_ACK_ viene inviato in seguito al controllo del checksum, che deve essere corretto.

Per raggiungere l'affidabilità su un canale inaffidabile, devo implementare un meccanismo di conferma della ricezione.
Se il mittente non vede arrivare una conferma di corretta ricezione, deve rinviare il pacchetto.

Questo meccanismo rileva: corruzione dei pacchetti, il pacchetto viene perso. Ma di per sè non risolve i pacchetti
duplicati.

Dopo un certo timeout il mittente si accorge che qualcosa è andato storto.

La gestione dei pacchetti duplicati si risolve identificato **univocamente** ogni pacchetto all'interno di una
sequenza.

Se il destinatario vede arrivarsi due volte un pacchetto con lo stesso numero, non lo considera nello stream.

Questo tipo di acknowledgment viene detto **esplicito**, ovvero il destinatario invia la conferma di ricevuta. Ma in
alcuni protocolli potremmo avere degli acknowledgement negativi.

Nello specifico contesto in cui un pacchetto sia arrivato corrotto, il destinatario può segnalarlo al mittente con un
_negative acknowledgement_ (NACK). Una segnalazione attiva di una trasmissione errata **non avviene**, perché è rara.

## Dimensionamento timeout

A livello di Ethernet, il timeout è costante (ad esempio nel caso di una ARP request). In TCP deve essre gestito in
modo intelligente: non troppo corto per non perdere degli ACK validi in contesti ad alta latenza, e nemmeno dei timeout
troppo lunghi per reagire più in fretta, ad esempio in una rete locale.

Il dimensionamento del timeout viene fatto adattivamente, _a runtime_, osservando come la comunicazione sta avvenendo.

## Connection oriented

Anche a livello 2 possono esistere protocolli orientati alla connessione, come PPP. Un protocollo connection-oriented
ha 3 fasi (ed è composto da 3 sottoprotocolli).

Non posso inviare dati direttamente se prima non ho "aperto" la connessione, inoltre durante il normale funzionamento
devo essere in grado di "chiudere" la connessione per terminarla correttamente.

Il problema della connessione si affronta a livello logico, perché non stiamo allocando risorse su canali fisici.
L'unica cosa che introduciamo è uno stato end-to-end. Non introduciamo un carico nella rete ma tra i due partecipanti
nella comunicazione.

Mantenere uno stato = occupare della memoria.

## Segmentazione

La divisione del flusso di dati in tanti pacchetti viene detta **segmentazione**, creando tanti segmenti. TCP cerca
anche di minimizzare il numero di volte in cui è necessario segmentare un dato, anche ai livelli inferiori.

La dimensione ideale dei segmenti TCP dovrebbe essere quella del _path MTU_. La dimensione massima (in UDP) è pari
alla dimensione massima inviabile tramite un payload IP, che eventualmente viene frammentato.

$$
MTU_{UDP} = 2^{16} - 1 - |\text{header IP}|
$$

## Sequence number

Il termine sequence number è il termine tecnico con cui contiamo i pacchetti che inviamo. Ogni segmento TCP che inviamo
ha un numero univoco detto sequence number. Consideriamo questo flusso di dati come un buffer di memoria, indirizzato
dal sequence number.

## Astrazioni

L'applicazione assume di star comunicando su un canale affidabile, ma nella realtà implementativa c'è un meccanismo che
si occupa di rendere affidabile un canale inaffidabile.

## Altre funzionalità

### Trasferimento con buffer

Vengono utilizzati per rendere le comunicazioni più performanti. È possibile che il SO decida di non inviare
immediatamente i dati, ma di conservali in memoria.

Ugualmente il destinatario: prima di inviare i dati che riceve al livello 3 potrebbe decidere di tenere i dati in
memoria.

### Full-duplex

Il canale di comunicazione consente a entrambi i partecipanti alla comunicazione di comunicare contemporaneamente.
C'è una distinzione tra client e server, ma una volta instaurata la comunicazione i ruoli spariscono concettualmente.
Nello scambiarsi i dati sono alla pari.

### Controllo di flusso

Funzionalità che cerca di regolare la velocità di invio dei dati end-to-end, in base alla capcità dei partecipanti.
Si tengono in considerazione: throughput, capacità dei comunicanti e della rete (congestione).

La velocità viene sempre rimodulata. Possiamo gestire situazioni in cui le risorse della rete vengono suddivise tra più
utenti.

### Funzioni non implementate

TCP non fornisce garanzie per comunicazioni in tempo reale.

Non fornisce nemmeno garanzie di disponibilità di banda tra mittente e destinatario.

Infine TCP è un protocollo unicast, e non c'è alcuna cognizione di comunicazione multicast. Abbiamo sempre e solo due
entità che comunicano tra di loro.

### Problemi

TCP viene utilizzato su host eterogenei, con tempi di trasmissione differenti su reti differenti, possibili ritardi
nella rete e capacità computazionali molto diverse.

## Segmento

L'header di un segmento TCP è più complesso rispetto a quello di UDP. Abbiamo sempre i numeri di porta: sorgente e
destinazione, di dimensione 16 bit l'uno.

In fondo c'è un checksum, analogo del tutto a quello di UDP (protegge l'integrità dell'header e del payload).

Il _sequence number_ è a 32 bit, inoltre c'è un ulteriore campo sempre da 32 bit che conferma un certo segmento.
Acknowledgment 1 conferma la ricezione del pacchetto 1 etc.

Scelta di design: perché mettiamo un campo aggiuntivo e non riutilizziamo il sequence number? Poiché il fusso è
bidirezionale, permettiamo a ogni segmento di svolgere una doppia funzione: inviare dati e confermare quelli ricevuti
contemporaneamente.

Questa possibilità è detta _piggybacking_.

Abbiamo un campo `hlen` che indica la dimensione dell'header: abbiamo dei campi opzionali che possiamo inserire.

`code bit` è un bitfield che specifica lo scopo e contenuto del segmento: `ack`, `urg` e `psh` cerca di dire a livello
4 mittente di inviare subito il dato (flush del buffer).

Gli ultimi 3 bit sono `syn`, `fin` e `rst` che vengono utilizzati per la gestione della connessione. `syn` viene
utilizzato solo quando instauriamo la connessione. Gli altri due sono legati alla chiusura della connessione.

Ci sono due bit perché ci sono due modi per chiudere la connessione.

`window size` definisce la dimensione della finestra in ricezione (quanti byte è in grado di ricevere).

### Dati urgent

`urgent pointer` punta al termine dei dati urgenti. Siccome non è stato definito abbastanza bene nello standard, viene
raramente uitlizzato e può essere soggetto a difformità nelle implementazioni dei vari sistemi operativi.

Urgent viene usato soltanto in un sottinsieme dei dati che cerchiamo di inviare. Nelle implementazioni moderne indica
sempre un byte, ovvero si è in grado di inviare in modo urgente un singolo byte. Spesso non è implementato bene, quindi
viene accettato come urgent solo il primo byte del payload. Va verificato sperimentale in base all'implementazione.

Questi possono essere: ctrl+C, ctrl+Z etc. Di fatto sono stati pensati per contesti applicativi interattivi (come ssh).

`tcpoptions` è un campo opzionale, di lunghezza variabile. Permette anche di negoziare l'MSS (maximum segment size),
per evitare che il segmento sia frammentato dal livello IP.

Infine dobbiamo mettere un padding di zeri per allineare la lunghezza dell'header a 32 bit.

Il mittente propone inizialmente come MTU il proprio, meno l'header IP. Nell'handshake viene deciso come MSS il minimo
tra i due proposti. Se nella comunicazione inviamo un dato con un payload che crea problemi legati al path MTU,
inferiori al MSS, possiamo rinegoziarlo con la stessa modalità.

Se non viene specificato, il default MSS è 536 byte. Vicino all'MTU minimo per ogni router collegato in Internet.

## Sequence number

Fin'ora li abbiamo considerati dei contatori, ma in realtà sono degli indici di memoria. I segmenti vengono contati a
partire da un numero indipendente e pseudo-casuale. Questo valore viene chiamato _initial sequence number_.
Introduciamo un offset, la posizione effettiva è $addr - ISN$.

Sono quindi indici di una memoria virtuale. Ogni volta che inviamo dati con TCP, incrementiamo il campo sequence number
di un valore pari al numero dei dati inviati.

Ogni volta che andiamo in overflow dal sequence number, ripartiamo da zero. Abbiamo un buffer circolare di memoria.
Possiamo superire il limite di 4GiB di dati inviabili.

## Acknowledgment number

Il numero di sequenza di ACK è uguale al sequence number del primo elemento che ci aspettiamo dopo l'ultimo ricevuto.
Poniamo di aver ricevuto tutti i pacchetti da 0 a 999, allora l'ACK avrà valore 1000.

Concettualmente è la stessa cosa: indica quello che **ci aspettiamo di ricevere**.

_Piggybacking_ $\to$ "portare a cavallo sulle spalle".

Esiste una certa latenza massima che un mittente può aspettare per unire un ACK con un invio dei dati. A livello di
standard esiste una piccola finestra temporale per cui io posso inviare l'ACK, per permettermi di avere dei dati da
inviare. Dettaglio tecnico minimo.

Con questo meccanismo non dobbiamo più creare pacchetti ad hoc per l'invio di ACK.

## Instaurare una connessione

$$
%importante
$$

Prima di iniziare una comunicazione, bisogna stabilire una connessione. Il paradigma è client-server: il server si
interfaccia col SO per mettersi in ascolto su una porta. Il client si collega verso un host su una particolare porta.

In UDP abbiamo visto (sperimentalmente) che venivano inviati dei pacchetti, mentre in TCP c'è una prima fase di
instaurazione.

### Three-way handshake

Nome canonico dato all'apertura di una connessione TCP perché composta dall'inivio di 3 pacchetti.

- il client manda una connection request (pacchetto con `SYN=1` e gli invia il suo ISN nel campo seq);

- il server risponde con un `SYN` `ACK` (ovvero attiva i bit sia di `SYN` che di `ACK`) e gli invia il suo ISN nel
campo sequence (e invia l'ISN del client+1 in ack);

- il client conferma definitivamente di aprire la connessione con un `ACK` (niente `SYN`) con sequence number uguale a
$\text{client\_isn}+1$ e ack di $\text{server\_isn}+1$.

I segmenti con `SYN` = 1 non possono avere payload. Per cui l'ack in risposta sarà `client_isn` + 1 perché il payload è
zero. Cosa interessante: il client e il server inizializzano due sequence number **indipendenti**.

Al termine di questi pacchetti sia client che server sono indistinguibili. Quando il client vuole inviare dei dati
incrementa il suo sequence number e viceversa il server.

Abbiamo quindi due flussi di dati veramente indipendenti. Così client e server hanno due stati esclusivi.

### Informazioni aggiuntive

Fra le informazioni aggiuntive inserite nelle opzioni del pacchetto di SYN del client, si può inserire il proprio
`Maximum Segment Size`. Questa informazione non viene sempre inviata.

Altra informazione legata al controllo di flusso, viene inviata anche la _maximum window size_, ovvero la quantità di
memoria allocata per il buffer di ricezione. L'altra entità non manderò mai più informazioni di quante indicate nella
window size del peer.

> _Se mi invii più di tot dati, devo scartarli (quindi non inviarmeli)_

## Chiudere connessione

Ci sono due tipi di chiusure, prima vediamo la chiusura cortese (polite). Si cerca di eseguire impostando il bit `FIN`
a 1 al server.

### Polite

Funziona in questo modo:

- il client invia il pacchetto `FIN`, che avrà il suo sequence number, ma segnala anche che è l'ultimo pacchetto che
invierà. Il server risponde con un `ACK`;

- successivamente il server invia un suo pacchetto `FIN` e il client conferma con un `ACK` la ricezione del pacchetto
`FIN` del server.

Abbiamo due pacchetti che possiamo considerare come flussi indipendenti. Il server e il client considerano la
connessione chiusa effettivamente in due momenti differenti: il server appena riceve l'ACK del client, mentre il client
dopo un _timed wait_ rispetto all'invio dell'ACK finale al server.

Perché funziona così? Perché devo fare un doppio scambio di messaggi?

Quando il server riceve il FIN, il SO segnala all'applicazione questa cosa. Assumiamo che ci sia un'applicazione che
debba fare cose per gestire questa chiusura. Come minimo la deallocazione della memoria necessaria a gestire la logica
applicativa.

Se il client chiude il suo endpoint, il server può continuare a inviargli dati.

Non ha rilevanza chi decida di chiudere la connessione per primo. Il fatto che ci siano client-server è fondamentale
per l'handshake ma una volta aperta la connessione il tipo di comunicazione è fullduplex.

### Unpolite

Il server può scegliere di chiudere la connessione forzatamente inviando un singolo pacchetto `RST`, la connessione
viene considerata chiusa.

Perché esistono due modalità? La chiusura polite è affidabile, mentre quella unpolite è l'unico protocollo di TCP che
non è affidabile. Il sottoprotocollo di chiusura (con reset) non è affidabile. Non c'è alcun ACK. La chiusura è best
effort.

In alcuni contesti applicativi un'entità che vuole chiudere la connessione non ha tempo per aspettare l'ACK.

L'alternativa è che il peer si accorgerà che starà comunicando con qualcuno che non ascolta più, mantenendo le risorse
per mantenere uno stato inutile in memoria.

Reset viene usato anche per negare una connessione a un client, ad esempio se mi accorgo che a livello applicativo
il peer parla un altro protocollo.
